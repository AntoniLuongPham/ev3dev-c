# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package ev3;
use base qw(Exporter);
use base qw(DynaLoader);
package ev3c;
bootstrap ev3;
package ev3;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package ev3;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package ev3;

*ev3_init = *ev3c::ev3_init;
*ev3_uninit = *ev3c::ev3_uninit;
*ev3_write_binary = *ev3c::ev3_write_binary;
*ev3_write = *ev3c::ev3_write;
*ev3_write_bool = *ev3c::ev3_write_bool;
*ev3_write_int = *ev3c::ev3_write_int;
*ev3_write_dword = *ev3c::ev3_write_dword;
*ev3_write_float = *ev3c::ev3_write_float;
*ev3_read_binary = *ev3c::ev3_read_binary;
*ev3_read = *ev3c::ev3_read;
*ev3_read_bool = *ev3c::ev3_read_bool;
*ev3_read_int = *ev3c::ev3_read_int;
*ev3_read_dword = *ev3c::ev3_read_dword;
*ev3_read_float = *ev3c::ev3_read_float;
*ev3_listdir = *ev3c::ev3_listdir;
*ev3_poweroff = *ev3c::ev3_poweroff;
*get_led_brightness = *ev3c::get_led_brightness;
*set_led_brightness = *ev3c::set_led_brightness;
*get_led_delay_off = *ev3c::get_led_delay_off;
*set_led_delay_off = *ev3c::set_led_delay_off;
*get_led_delay_on = *ev3c::get_led_delay_on;
*set_led_delay_on = *ev3c::set_led_delay_on;
*get_led_trigger = *ev3c::get_led_trigger;
*set_led_trigger = *ev3c::set_led_trigger;
*get_led_trigger_inx = *ev3c::get_led_trigger_inx;
*set_led_trigger_inx = *ev3c::set_led_trigger_inx;
*set_light = *ev3c::set_light;
*get_light = *ev3c::get_light;
*set_light_trigger = *ev3c::set_light_trigger;
*get_light_trigger = *ev3c::get_light_trigger;
*set_light_blink = *ev3c::set_light_blink;
*get_light_blink = *ev3c::get_light_blink;
*get_sensor_bin_data = *ev3c::get_sensor_bin_data;
*set_sensor_bin_data = *ev3c::set_sensor_bin_data;
*get_sensor_bin_data_format = *ev3c::get_sensor_bin_data_format;
*get_sensor_dp = *ev3c::get_sensor_dp;
*get_sensor_fw_version = *ev3c::get_sensor_fw_version;
*get_sensor_i2c_addr = *ev3c::get_sensor_i2c_addr;
*get_sensor_mode = *ev3c::get_sensor_mode;
*set_sensor_mode = *ev3c::set_sensor_mode;
*get_sensor_modes = *ev3c::get_sensor_modes;
*get_sensor_num_values = *ev3c::get_sensor_num_values;
*get_sensor_poll_ms = *ev3c::get_sensor_poll_ms;
*set_sensor_poll_ms = *ev3c::set_sensor_poll_ms;
*get_sensor_port_name = *ev3c::get_sensor_port_name;
*get_sensor_units = *ev3c::get_sensor_units;
*get_sensor_type_id = *ev3c::get_sensor_type_id;
*get_sensor_value0 = *ev3c::get_sensor_value0;
*get_sensor_value1 = *ev3c::get_sensor_value1;
*get_sensor_value2 = *ev3c::get_sensor_value2;
*get_sensor_value3 = *ev3c::get_sensor_value3;
*get_sensor_value4 = *ev3c::get_sensor_value4;
*get_sensor_value5 = *ev3c::get_sensor_value5;
*get_sensor_value6 = *ev3c::get_sensor_value6;
*get_sensor_value7 = *ev3c::get_sensor_value7;
*get_sensor_value = *ev3c::get_sensor_value;
*ev3_sensor_type = *ev3c::ev3_sensor_type;
*ev3_sensor_port = *ev3c::ev3_sensor_port;
*ev3_get_sensor = *ev3c::ev3_get_sensor;
*ev3_get_sensor_connected = *ev3c::ev3_get_sensor_connected;
*ev3_get_sensor_id = *ev3c::ev3_get_sensor_id;
*ev3_get_sensor_type_id = *ev3c::ev3_get_sensor_type_id;
*ev3_sensor_init = *ev3c::ev3_sensor_init;
*get_tacho_duty_cycle = *ev3c::get_tacho_duty_cycle;
*get_tacho_duty_cycle_sp = *ev3c::get_tacho_duty_cycle_sp;
*set_tacho_duty_cycle_sp = *ev3c::set_tacho_duty_cycle_sp;
*get_tacho_polarity_mode = *ev3c::get_tacho_polarity_mode;
*get_tacho_port_name = *ev3c::get_tacho_port_name;
*get_tacho_position = *ev3c::get_tacho_position;
*set_tacho_position = *ev3c::set_tacho_position;
*get_tacho_position_mode = *ev3c::get_tacho_position_mode;
*set_tacho_position_mode = *ev3c::set_tacho_position_mode;
*get_tacho_position_sp = *ev3c::get_tacho_position_sp;
*set_tacho_position_sp = *ev3c::set_tacho_position_sp;
*get_tacho_pulses_per_second = *ev3c::get_tacho_pulses_per_second;
*get_tacho_pulses_per_second_sp = *ev3c::get_tacho_pulses_per_second_sp;
*set_tacho_pulses_per_second_sp = *ev3c::set_tacho_pulses_per_second_sp;
*get_tacho_ramp_down_sp = *ev3c::get_tacho_ramp_down_sp;
*set_tacho_ramp_down_sp = *ev3c::set_tacho_ramp_down_sp;
*get_tacho_ramp_up_sp = *ev3c::get_tacho_ramp_up_sp;
*set_tacho_ramp_up_sp = *ev3c::set_tacho_ramp_up_sp;
*get_tacho_regulation_mode = *ev3c::get_tacho_regulation_mode;
*set_tacho_regulation_mode = *ev3c::set_tacho_regulation_mode;
*set_tacho_reset = *ev3c::set_tacho_reset;
*get_tacho_run = *ev3c::get_tacho_run;
*set_tacho_run = *ev3c::set_tacho_run;
*get_tacho_run_mode = *ev3c::get_tacho_run_mode;
*set_tacho_run_mode = *ev3c::set_tacho_run_mode;
*get_tacho_speed_regulation_D = *ev3c::get_tacho_speed_regulation_D;
*set_tacho_speed_regulation_D = *ev3c::set_tacho_speed_regulation_D;
*get_tacho_speed_regulation_I = *ev3c::get_tacho_speed_regulation_I;
*set_tacho_speed_regulation_I = *ev3c::set_tacho_speed_regulation_I;
*get_tacho_speed_regulation_K = *ev3c::get_tacho_speed_regulation_K;
*set_tacho_speed_regulation_K = *ev3c::set_tacho_speed_regulation_K;
*get_tacho_speed_regulation_P = *ev3c::get_tacho_speed_regulation_P;
*set_tacho_speed_regulation_P = *ev3c::set_tacho_speed_regulation_P;
*get_tacho_state = *ev3c::get_tacho_state;
*get_tacho_stop_mode = *ev3c::get_tacho_stop_mode;
*set_tacho_stop_mode = *ev3c::set_tacho_stop_mode;
*get_tacho_stop_modes = *ev3c::get_tacho_stop_modes;
*get_tacho_time_sp = *ev3c::get_tacho_time_sp;
*set_tacho_time_sp = *ev3c::set_tacho_time_sp;
*get_tacho_type = *ev3c::get_tacho_type;
*ev3_tacho_type = *ev3c::ev3_tacho_type;
*ev3_tacho_port = *ev3c::ev3_tacho_port;
*ev3_get_tacho = *ev3c::ev3_get_tacho;
*ev3_get_tacho_connected = *ev3c::ev3_get_tacho_connected;
*ev3_get_tacho_id = *ev3c::ev3_get_tacho_id;
*ev3_get_tacho_type_id = *ev3c::ev3_get_tacho_type_id;
*ev3_tacho_init = *ev3c::ev3_tacho_init;

############# Class : ev3::EV3_SENSOR ##############

package ev3::EV3_SENSOR;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ev3 );
%OWNER = ();
%ITERATORS = ();
*swig_connected_get = *ev3c::EV3_SENSOR_connected_get;
*swig_connected_set = *ev3c::EV3_SENSOR_connected_set;
*swig_id_get = *ev3c::EV3_SENSOR_id_get;
*swig_id_set = *ev3c::EV3_SENSOR_id_set;
*swig_type_id_get = *ev3c::EV3_SENSOR_type_id_get;
*swig_type_id_set = *ev3c::EV3_SENSOR_type_id_set;
sub new {
    my $pkg = shift;
    my $self = ev3c::new_EV3_SENSOR(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ev3c::delete_EV3_SENSOR($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ev3::EV3_TACHO ##############

package ev3::EV3_TACHO;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ev3 );
%OWNER = ();
%ITERATORS = ();
*swig_connected_get = *ev3c::EV3_TACHO_connected_get;
*swig_connected_set = *ev3c::EV3_TACHO_connected_set;
*swig_id_get = *ev3c::EV3_TACHO_id_get;
*swig_id_set = *ev3c::EV3_TACHO_id_set;
*swig_type_id_get = *ev3c::EV3_TACHO_type_id_get;
*swig_type_id_set = *ev3c::EV3_TACHO_type_id_set;
sub new {
    my $pkg = shift;
    my $self = ev3c::new_EV3_TACHO(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ev3c::delete_EV3_TACHO($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package ev3;

*EV3_BRICK = *ev3c::EV3_BRICK;
*EV3_NONE = *ev3c::EV3_NONE;
*brick_addr = *ev3c::brick_addr;
*brick_port = *ev3c::brick_port;
*EV3_GREEN_LEFT = *ev3c::EV3_GREEN_LEFT;
*EV3_GREEN_RIGHT = *ev3c::EV3_GREEN_RIGHT;
*EV3_RED_LEFT = *ev3c::EV3_RED_LEFT;
*EV3_RED_RIGHT = *ev3c::EV3_RED_RIGHT;
*LED__COUNT_ = *ev3c::LED__COUNT_;
*TRIGGER_NONE = *ev3c::TRIGGER_NONE;
*TRIGGER_MMC0 = *ev3c::TRIGGER_MMC0;
*TRIGGER_TIMER = *ev3c::TRIGGER_TIMER;
*TRIGGER_HEARTBEAT = *ev3c::TRIGGER_HEARTBEAT;
*TRIGGER_DEFAULT_ON = *ev3c::TRIGGER_DEFAULT_ON;
*TRIGGER_LEGOEV3_BATTERY_CHARGING_OR_FULL = *ev3c::TRIGGER_LEGOEV3_BATTERY_CHARGING_OR_FULL;
*TRIGGER_LEGOEV3_BATTERY_CHARGING = *ev3c::TRIGGER_LEGOEV3_BATTERY_CHARGING;
*TRIGGER_LEGOEV3_BATTERY_FULL = *ev3c::TRIGGER_LEGOEV3_BATTERY_FULL;
*TRIGGER_LEGOEV3_BATTERY_CHARGING_BLINK_FULL_SOLID = *ev3c::TRIGGER_LEGOEV3_BATTERY_CHARGING_BLINK_FULL_SOLID;
*TRIGGER_PHY0RX = *ev3c::TRIGGER_PHY0RX;
*TRIGGER_PHY0TX = *ev3c::TRIGGER_PHY0TX;
*TRIGGER_PHY0ASSOC = *ev3c::TRIGGER_PHY0ASSOC;
*TRIGGER_PHY0RADIO = *ev3c::TRIGGER_PHY0RADIO;
*TRIGGER_PHY0TPT = *ev3c::TRIGGER_PHY0TPT;
*TRIGGER__COUNT_ = *ev3c::TRIGGER__COUNT_;
*LIT_LEFT = *ev3c::LIT_LEFT;
*LIT_RIGHT = *ev3c::LIT_RIGHT;
*LIT__LOC__ = *ev3c::LIT__LOC__;
*LIT_OFF = *ev3c::LIT_OFF;
*LIT_GREEN = *ev3c::LIT_GREEN;
*LIT_RED = *ev3c::LIT_RED;
*LIT_AMBER = *ev3c::LIT_AMBER;
*LIT__COL__ = *ev3c::LIT__COL__;
*INPUT_1 = *ev3c::INPUT_1;
*INPUT_2 = *ev3c::INPUT_2;
*INPUT_3 = *ev3c::INPUT_3;
*INPUT_4 = *ev3c::INPUT_4;
*INPUT__COUNT_ = *ev3c::INPUT__COUNT_;

my %__ev3_sensor_hash;
tie %__ev3_sensor_hash,"ev3::EV3_SENSOR", $ev3c::ev3_sensor;
$ev3_sensor= \%__ev3_sensor_hash;
bless $ev3_sensor, ev3::EV3_SENSOR;
*EV3_TOUCH = *ev3c::EV3_TOUCH;
*EV3_COLOR = *ev3c::EV3_COLOR;
*EV3_ULTRASONIC = *ev3c::EV3_ULTRASONIC;
*EV3_GYRO = *ev3c::EV3_GYRO;
*EV3_INFRARED = *ev3c::EV3_INFRARED;
*OUTPUT_A = *ev3c::OUTPUT_A;
*OUTPUT_B = *ev3c::OUTPUT_B;
*OUTPUT_C = *ev3c::OUTPUT_C;
*OUTPUT_D = *ev3c::OUTPUT_D;
*OUTPUT__COUNT_ = *ev3c::OUTPUT__COUNT_;

my %__ev3_tacho_hash;
tie %__ev3_tacho_hash,"ev3::EV3_TACHO", $ev3c::ev3_tacho;
$ev3_tacho= \%__ev3_tacho_hash;
bless $ev3_tacho, ev3::EV3_TACHO;
*TACHO = *ev3c::TACHO;
*MINITACHO = *ev3c::MINITACHO;
1;
