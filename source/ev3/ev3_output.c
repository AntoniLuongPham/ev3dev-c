
/*  ev3_output.c was generated by yup.py (yupp) 0.7b6
    out of ev3_output.yu-c at 2014-11-09 00:39
 *//**
 *  \file  ev3_output.c (ev3_output.yu-c)
 *  \brief  EV3 output ports.
 *  \author  Vitaly Kravtsov (in4lio@gmail.com)
 *  \copyright  See the LICENSE file.
 */

#define EV3_OUTPUT_IMPLEMENT

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "ev3.h"
#include "ev3_port.h"
#include "ev3_output.h"

const char * const output_attr_mode[] = {
	"/sys/bus/legoev3/devices" "/" "out" "A" "/" "mode",
	"/sys/bus/legoev3/devices" "/" "out" "B" "/" "mode",
	"/sys/bus/legoev3/devices" "/" "out" "C" "/" "mode",
	"/sys/bus/legoev3/devices" "/" "out" "D" "/" "mode",

};

const char * const output_attr_modes[] = {
	"/sys/bus/legoev3/devices" "/" "out" "A" "/" "modes",
	"/sys/bus/legoev3/devices" "/" "out" "B" "/" "modes",
	"/sys/bus/legoev3/devices" "/" "out" "C" "/" "modes",
	"/sys/bus/legoev3/devices" "/" "out" "D" "/" "modes",

};

const char * const output_attr_pin5_mv[] = {
	"/sys/bus/legoev3/devices" "/" "out" "A" "/" "pin5_mv",
	"/sys/bus/legoev3/devices" "/" "out" "B" "/" "pin5_mv",
	"/sys/bus/legoev3/devices" "/" "out" "C" "/" "pin5_mv",
	"/sys/bus/legoev3/devices" "/" "out" "D" "/" "pin5_mv",

};

const char * const output_attr_state[] = {
	"/sys/bus/legoev3/devices" "/" "out" "A" "/" "state",
	"/sys/bus/legoev3/devices" "/" "out" "B" "/" "state",
	"/sys/bus/legoev3/devices" "/" "out" "C" "/" "state",
	"/sys/bus/legoev3/devices" "/" "out" "D" "/" "state",

};

size_t get_output_mode( uint8_t inx, char *buf, size_t sz )
{
	uint8_t n = inx - OUTPUT__BASE_;

	if ( n >= OUTPUT__COUNT_ ) return ( 0 );

	return ev3_read_char_array( output_attr_mode[ n ], buf, sz );
}

size_t set_output_mode( uint8_t inx, char *value )
{
	uint8_t n = inx - OUTPUT__BASE_;

	if ( n >= OUTPUT__COUNT_ ) return ( 0 );

	return ev3_write_char_array( output_attr_mode[ n ], value );
}

size_t get_output_modes( uint8_t inx, char *buf, size_t sz )
{
	uint8_t n = inx - OUTPUT__BASE_;

	if ( n >= OUTPUT__COUNT_ ) return ( 0 );

	return ev3_read_char_array( output_attr_modes[ n ], buf, sz );
}

size_t get_output_pin5_mv( uint8_t inx, int *buf )
{
	uint8_t n = inx - OUTPUT__BASE_;

	if ( n >= OUTPUT__COUNT_ ) return ( 0 );

	return ev3_read_int( output_attr_pin5_mv[ n ], buf );
}

size_t get_output_state( uint8_t inx, char *buf, size_t sz )
{
	uint8_t n = inx - OUTPUT__BASE_;

	if ( n >= OUTPUT__COUNT_ ) return ( 0 );

	return ev3_read_char_array( output_attr_state[ n ], buf, sz );
}

const char *ev3_output_mode( uint8_t mode_inx )
{
	switch ( mode_inx ) {
	case OUTPUT_AUTO:
		return "auto";
	case OUTPUT_EV3_TACHO_MOTOR:
		return "ev3-tacho-motor";
	case OUTPUT_RCX_MOTOR:
		return "rcx-motor";
	case OUTPUT_RCX_LED:
		return "rcx-led";
	case OUTPUT_RAW:
		return "raw";

	}
	return STR_unknown_;
}

uint8_t get_output_mode_inx( uint8_t inx )
{
	char buf[ 64 ];

	if ( !get_output_mode( inx, buf, sizeof( buf ))) return ( OUTPUT_MODE__COUNT_ );

	if ( strcmp( buf, "auto" ) == 0 ) return OUTPUT_AUTO;
	if ( strcmp( buf, "ev3-tacho-motor" ) == 0 ) return OUTPUT_EV3_TACHO_MOTOR;
	if ( strcmp( buf, "rcx-motor" ) == 0 ) return OUTPUT_RCX_MOTOR;
	if ( strcmp( buf, "rcx-led" ) == 0 ) return OUTPUT_RCX_LED;
	if ( strcmp( buf, "raw" ) == 0 ) return OUTPUT_RAW;

	return ( OUTPUT_MODE__COUNT_ );
}

size_t set_output_mode_inx( uint8_t inx, uint8_t mode_inx )
{
	return set_output_mode( inx, ( char* ) ev3_output_mode( mode_inx ));
}

uint8_t ev3_output_inx( const char *name )
{
	if ( strcmp( name, "outA" ) == 0 ) return OUTPUT_A;
	if ( strcmp( name, "outB" ) == 0 ) return OUTPUT_B;
	if ( strcmp( name, "outC" ) == 0 ) return OUTPUT_C;
	if ( strcmp( name, "outD" ) == 0 ) return OUTPUT_D;

	return ( EV3_PORT__NONE_ );
}

const char *ev3_output_name( uint8_t inx )
{
	switch ( inx ) {
	case OUTPUT_A:
		return "outA";
	case OUTPUT_B:
		return "outB";
	case OUTPUT_C:
		return "outC";
	case OUTPUT_D:
		return "outD";

	}
	return STR_unknown_;
}
