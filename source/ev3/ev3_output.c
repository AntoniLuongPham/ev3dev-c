
/*  ev3_output.c was generated by yup.py (yupp) 0.7b7
    out of ev3_output.yu-c at 2014-11-27 15:29
 *//**
 *  \file  ev3_output.c (ev3_output.yu-c)
 *  \brief  EV3 output ports.
 *  \author  Vitaly Kravtsov (in4lio@gmail.com)
 *  \copyright  See the LICENSE file.
 */

#define EV3_OUTPUT_IMPLEMENT

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "ev3.h"
#include "ev3_port.h"
#include "ev3_output.h"

static const char * const output_attr_mode[] = {
	"/sys/bus/legoev3/devices/outA/mode",
	"/sys/bus/legoev3/devices/outB/mode",
	"/sys/bus/legoev3/devices/outC/mode",
	"/sys/bus/legoev3/devices/outD/mode",

};

static const char * const output_attr_modes[] = {
	"/sys/bus/legoev3/devices/outA/modes",
	"/sys/bus/legoev3/devices/outB/modes",
	"/sys/bus/legoev3/devices/outC/modes",
	"/sys/bus/legoev3/devices/outD/modes",

};

static const char * const output_attr_pin5_mv[] = {
	"/sys/bus/legoev3/devices/outA/pin5_mv",
	"/sys/bus/legoev3/devices/outB/pin5_mv",
	"/sys/bus/legoev3/devices/outC/pin5_mv",
	"/sys/bus/legoev3/devices/outD/pin5_mv",

};

static const char * const output_attr_state[] = {
	"/sys/bus/legoev3/devices/outA/state",
	"/sys/bus/legoev3/devices/outB/state",
	"/sys/bus/legoev3/devices/outC/state",
	"/sys/bus/legoev3/devices/outD/state",

};

uint8_t ev3_output_inx( const char *name )
{
	if ( strncmp( name, "outA", 4 ) == 0 ) return OUTPUT_A;
	if ( strncmp( name, "outB", 4 ) == 0 ) return OUTPUT_B;
	if ( strncmp( name, "outC", 4 ) == 0 ) return OUTPUT_C;
	if ( strncmp( name, "outD", 4 ) == 0 ) return OUTPUT_D;

	return ( EV3_PORT__NONE_ );
}

const char *ev3_output_name( uint8_t port )
{
	switch ( port ) {
	case OUTPUT_A:
		return "outA";
	case OUTPUT_B:
		return "outB";
	case OUTPUT_C:
		return "outC";
	case OUTPUT_D:
		return "outD";

	}
	return STR_unknown_;
}

size_t get_output_mode( uint8_t port, char *buf, size_t sz )
{
	uint8_t n = port - OUTPUT__BASE_;

	if ( n >= OUTPUT__COUNT_ ) return ( 0 );

	return ev3_read_char_array( output_attr_mode[ n ], buf, sz );
}

size_t set_output_mode( uint8_t port, char *value )
{
	uint8_t n = port - OUTPUT__BASE_;

	if ( n >= OUTPUT__COUNT_ ) return ( 0 );

	return ev3_write_char_array( output_attr_mode[ n ], value );
}

size_t get_output_modes( uint8_t port, char *buf, size_t sz )
{
	uint8_t n = port - OUTPUT__BASE_;

	if ( n >= OUTPUT__COUNT_ ) return ( 0 );

	return ev3_read_char_array( output_attr_modes[ n ], buf, sz );
}

size_t get_output_pin5_mv( uint8_t port, int *buf )
{
	uint8_t n = port - OUTPUT__BASE_;

	if ( n >= OUTPUT__COUNT_ ) return ( 0 );

	return ev3_read_int( output_attr_pin5_mv[ n ], buf );
}

size_t get_output_state( uint8_t port, char *buf, size_t sz )
{
	uint8_t n = port - OUTPUT__BASE_;

	if ( n >= OUTPUT__COUNT_ ) return ( 0 );

	return ev3_read_char_array( output_attr_state[ n ], buf, sz );
}

const char *ev3_output_mode( uint8_t mode_inx )
{
	switch ( mode_inx ) {
	case OUTPUT_AUTO:
		return "auto";
	case OUTPUT_EV3_TACHO_MOTOR:
		return "ev3-tacho-motor";
	case OUTPUT_RCX_MOTOR:
		return "rcx-motor";
	case OUTPUT_RCX_LED:
		return "rcx-led";
	case OUTPUT_RAW:
		return "raw";

	}
	return STR_unknown_;
}

uint8_t get_output_mode_inx( uint8_t port )
{
	char buf[ 64 ];

	if ( !get_output_mode( port, buf, sizeof( buf ))) return ( OUTPUT_MODE__COUNT_ );

	if ( strcmp( buf, "auto" ) == 0 ) return OUTPUT_AUTO;
	if ( strcmp( buf, "ev3-tacho-motor" ) == 0 ) return OUTPUT_EV3_TACHO_MOTOR;
	if ( strcmp( buf, "rcx-motor" ) == 0 ) return OUTPUT_RCX_MOTOR;
	if ( strcmp( buf, "rcx-led" ) == 0 ) return OUTPUT_RCX_LED;
	if ( strcmp( buf, "raw" ) == 0 ) return OUTPUT_RAW;

	return ( OUTPUT_MODE__COUNT_ );
}

size_t set_output_mode_inx( uint8_t port, uint8_t mode_inx )
{
	return set_output_mode( port, ( char* ) ev3_output_mode( mode_inx ));
}

