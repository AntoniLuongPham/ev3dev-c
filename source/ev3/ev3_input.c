
/*  ev3_input.c was generated by yup.py (yupp) 0.7b7
    out of ev3_input.yu-c at 2014-11-27 15:29
 *//**
 *  \file  ev3_input.c (ev3_input.yu-c)
 *  \brief  EV3 Input Ports.
 *  \author  Vitaly Kravtsov (in4lio@gmail.com)
 *  \copyright  See the LICENSE file.
 */

#define EV3_INPUT_IMPLEMENT

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "ev3.h"
#include "ev3_port.h"
#include "ev3_input.h"

static const char * const input_attr_mode[] = {
	"/sys/bus/legoev3/devices/in1/mode",
	"/sys/bus/legoev3/devices/in2/mode",
	"/sys/bus/legoev3/devices/in3/mode",
	"/sys/bus/legoev3/devices/in4/mode",

};

static const char * const input_attr_modes[] = {
	"/sys/bus/legoev3/devices/in1/modes",
	"/sys/bus/legoev3/devices/in2/modes",
	"/sys/bus/legoev3/devices/in3/modes",
	"/sys/bus/legoev3/devices/in4/modes",

};

static const char * const input_attr_pin1_mv[] = {
	"/sys/bus/legoev3/devices/in1/pin1_mv",
	"/sys/bus/legoev3/devices/in2/pin1_mv",
	"/sys/bus/legoev3/devices/in3/pin1_mv",
	"/sys/bus/legoev3/devices/in4/pin1_mv",

};

static const char * const input_attr_pin6_mv[] = {
	"/sys/bus/legoev3/devices/in1/pin6_mv",
	"/sys/bus/legoev3/devices/in2/pin6_mv",
	"/sys/bus/legoev3/devices/in3/pin6_mv",
	"/sys/bus/legoev3/devices/in4/pin6_mv",

};

static const char * const input_attr_state[] = {
	"/sys/bus/legoev3/devices/in1/state",
	"/sys/bus/legoev3/devices/in2/state",
	"/sys/bus/legoev3/devices/in3/state",
	"/sys/bus/legoev3/devices/in4/state",

};

uint8_t ev3_input_inx( const char *name )
{
	if ( strncmp( name, "in1", 3 ) == 0 ) return INPUT_1;
	if ( strncmp( name, "in2", 3 ) == 0 ) return INPUT_2;
	if ( strncmp( name, "in3", 3 ) == 0 ) return INPUT_3;
	if ( strncmp( name, "in4", 3 ) == 0 ) return INPUT_4;

	return ( EV3_PORT__NONE_ );
}

const char *ev3_input_name( uint8_t port )
{
	switch ( port ) {
	case INPUT_1:
		return "in1";
	case INPUT_2:
		return "in2";
	case INPUT_3:
		return "in3";
	case INPUT_4:
		return "in4";

	}
	return STR_unknown_;
}

size_t get_input_mode( uint8_t port, char *buf, size_t sz )
{
	uint8_t n = port - INPUT__BASE_;

	if ( n >= INPUT__COUNT_ ) return ( 0 );

	return ev3_read_char_array( input_attr_mode[ n ], buf, sz );
}

size_t set_input_mode( uint8_t port, char *value )
{
	uint8_t n = port - INPUT__BASE_;

	if ( n >= INPUT__COUNT_ ) return ( 0 );

	return ev3_write_char_array( input_attr_mode[ n ], value );
}

size_t get_input_modes( uint8_t port, char *buf, size_t sz )
{
	uint8_t n = port - INPUT__BASE_;

	if ( n >= INPUT__COUNT_ ) return ( 0 );

	return ev3_read_char_array( input_attr_modes[ n ], buf, sz );
}

size_t get_input_pin1_mv( uint8_t port, int *buf )
{
	uint8_t n = port - INPUT__BASE_;

	if ( n >= INPUT__COUNT_ ) return ( 0 );

	return ev3_read_int( input_attr_pin1_mv[ n ], buf );
}

size_t get_input_pin6_mv( uint8_t port, int *buf )
{
	uint8_t n = port - INPUT__BASE_;

	if ( n >= INPUT__COUNT_ ) return ( 0 );

	return ev3_read_int( input_attr_pin6_mv[ n ], buf );
}

size_t get_input_state( uint8_t port, char *buf, size_t sz )
{
	uint8_t n = port - INPUT__BASE_;

	if ( n >= INPUT__COUNT_ ) return ( 0 );

	return ev3_read_char_array( input_attr_state[ n ], buf, sz );
}

const char *ev3_input_mode( uint8_t mode_inx )
{
	switch ( mode_inx ) {
	case INPUT_AUTO:
		return "auto";
	case INPUT_EV3_ANALOG:
		return "ev3-analog";
	case INPUT_EV3_UART:
		return "ev3-uart";
	case INPUT_NXT_ANALOG:
		return "nxt-analog";
	case INPUT_NXT_COLOR:
		return "nxt-color";
	case INPUT_NXT_I2C:
		return "nxt-i2c";
	case INPUT_OTHER_UART:
		return "other-uart";
	case INPUT_RAW:
		return "raw";

	}
	return STR_unknown_;
}

uint8_t get_input_mode_inx( uint8_t port )
{
	char buf[ 64 ];

	if ( !get_input_mode( port, buf, sizeof( buf ))) return ( INPUT_MODE__COUNT_ );

	if ( strcmp( buf, "auto" ) == 0 ) return INPUT_AUTO;
	if ( strcmp( buf, "ev3-analog" ) == 0 ) return INPUT_EV3_ANALOG;
	if ( strcmp( buf, "ev3-uart" ) == 0 ) return INPUT_EV3_UART;
	if ( strcmp( buf, "nxt-analog" ) == 0 ) return INPUT_NXT_ANALOG;
	if ( strcmp( buf, "nxt-color" ) == 0 ) return INPUT_NXT_COLOR;
	if ( strcmp( buf, "nxt-i2c" ) == 0 ) return INPUT_NXT_I2C;
	if ( strcmp( buf, "other-uart" ) == 0 ) return INPUT_OTHER_UART;
	if ( strcmp( buf, "raw" ) == 0 ) return INPUT_RAW;

	return ( INPUT_MODE__COUNT_ );
}

size_t set_input_mode_inx( uint8_t port, uint8_t mode_inx )
{
	return set_input_mode( port, ( char* ) ev3_input_mode( mode_inx ));
}

